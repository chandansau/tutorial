<!DOCTYPE html>
<html>
<head>
	<title>EW Technologies online learning</title>
       <center><h1><font color="maroon"><u>STRUCTS</u></font></h1></center>

</head>
<body style="background-color:aliceblue ; color: maroon" id="test" onmousedown='return false;' onselectstart='return false;'><font size="4">
                    <p>Structs are complex data types, meaning that they are made up of multiple values. You then create an instance of the struct and fill in its values, then you can pass it around as a single value in your code. For example, we could define a <code>Person</code> struct type that contains two properties: <code>clothes</code> and <code>shoes</code>:</p>
<pre><code class="language-swift">struct Person {
    var clothes: String
    var shoes: String
}</code></pre>
<p>When you define a struct, Swift makes them very easy to create because it automatically generates what's called a memberwise initializer. In plain speak, it means you create the struct by passing in initial values for its two properties, like this:</p>
<pre><code class="language-swift">let taylor = Person(clothes: "T-shirts", shoes: "sneakers")
let other = Person(clothes: "short skirts", shoes: "high heels")</code></pre>
<p>Once you have created an instance of a struct, you can read its properties just by writing the name of the struct, a period, then the property you want to read:</p>
<pre><code class="language-swift">print(taylor.clothes)
print(other.shoes)</code></pre>
<p>If you assign one struct to another, Swift copies it behind the scenes so that it is a complete, standalone duplicate of the original. Well, that's not strictly true: Swift uses a technique called &quot;copy on write&quot; which means it only actually copies your data if you try to change it.</p>
<p>To help you see how struct copies work, put this into your playground:</p>
<pre><code class="language-swift">struct Person {
    var clothes: String
    var shoes: String
}

let taylor = Person(clothes: "T-shirts", shoes: "sneakers")
let other = Person(clothes: "short skirts", shoes: "high heels")

var taylorCopy = taylor
taylorCopy.shoes = "flip flops"

print(taylor)
print(taylorCopy)</code></pre>
<p>That creates two <code>Person</code> structs, then creates a third one called <code>taylorCopy</code> as a copy of <code>taylor</code>. What happens next is the interesting part: the code changes <code>taylorCopy</code>, and prints both it and <code>taylor</code>. If you look in your results pane (you might need to resize it to fit) you'll see that the copy has a different value to the original: changing one did not change the other.</p>
    <font color="#00008b" size="6">Functions inside structs</font>
<p>You can place functions inside structs, and in fact it’s a good idea to do so for all functions that read or change data inside the struct. For example, we could add a function to our <code>Person</code> struct to describe what they are wearing, like this:</p>
<pre><code class="language-swift">struct Person {
    var clothes: String
    var shoes: String

    func describe() {
        print("I like wearing \(clothes) with \(shoes)")
    }
}</code></pre>
<p>There are two more things you ought to know but can't see in that code.</p>
<p>First, when you write a function inside a struct, it's called a <em>method</em> instead. In Swift you write <code>func</code> whether it's a function or a method, but the distinction is preserved when you talk about them.</p>
<p>Second, if you want to have some part of Apple’s operating system call your Swift method, you need to mark it with a special attribute: <code>@objc</code>. This is short for “Objective-C”, and the attribute effectively marks the method as being available for older Objective-C code to run – which is almost all of iOS, macOS, watchOS, and tvOS. For example, if you ask the system to call your method after one second has passed, you’ll need to mark it with <code>@objc</code>.</p>
<p>Don’t worry too much about <code>@objc</code> for now – not only will I be explaining it in context later on, but Xcode will always tell you when it’s needed. Alternatively, if you don’t want to use <code>@objc</code> for individual methods you can put <code>@objcMembers</code> before your struct to automatically make all its methods available to Objective-C.</p>
</font>
<marquee>  <font color="purple" ><h1>END STRUCTS</h1></font></marquee><br>

</body>
</html>